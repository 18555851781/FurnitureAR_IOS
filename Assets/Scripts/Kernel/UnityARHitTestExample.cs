using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;

namespace UnityEngine.XR.iOS
{
	public class UnityARHitTestExample : MonoBehaviour
	{
		Transform Self_Transform;
		public float maxRayDistance = 30.0f;
		public LayerMask collisionLayer = 1 << 10;  //ARKitPlane layer

        //  进行touch时的开始点
        Touch BeginTouch1;
        Touch BeginTouch2;

        private void Start()
        {
            Self_Transform = transform;
        }

        bool HitTestWithResultType (ARPoint point, ARHitTestResultType resultTypes)
        {
            List<ARHitTestResult> hitResults = UnityARSessionNativeInterface.GetARSessionNativeInterface ().HitTest (point, resultTypes);
            if (hitResults.Count > 0) {
                foreach (var hitResult in hitResults) 
                {
                    Debug.Log ("Got hit!");
                    Self_Transform.position = Vector3.Lerp(transform.position,UnityARMatrixOps.GetPosition(hitResult.worldTransform),1f);
                    //Self_Transform.rotation = UnityARMatrixOps.GetRotation (hitResult.worldTransform);
                    Debug.Log (string.Format ("x:{0:0.######} y:{1:0.######} z:{2:0.######}", Self_Transform.position.x, Self_Transform.position.y, Self_Transform.position.z));
                    return true;
                }
            }
            return false;
        }
		
		// Update is called once per frame
		private void Update () 
        {

			#if UNITY_EDITOR   //we will only use this script on the editor side, though there is nothing that would prevent it from working on device
			if (Input.GetMouseButtonDown (0)) 
            {
				Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);
				RaycastHit hit;
				
				//we'll try to hit one of the plane collider gameobjects that were generated by the plugin
				//effectively similar to calling HitTest with ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent
				if (Physics.Raycast (ray, out hit, maxRayDistance, collisionLayer))
                {
					//we're going to get the position from the contact point
                    Self_Transform.position = hit.point;
                    Debug.Log (string.Format ("x:{0:0.######} y:{1:0.######} z:{2:0.######}", Self_Transform.position.x, Self_Transform.position.y, Self_Transform.position.z));

					//and the rotation from the transform of the plane collider
                    //Self_Transform.rotation = hit.transform.rotation;
				}
			}
			#else

            //  手机上使用touch去确定触摸点

            if (Input.touchCount > 0 && Self_Transform != null)
			{
            //  判断单指点击以及没有按到UI部分
                if(Input.touchCount == 1 && !EventSystem.current.currentSelectedGameObject)
                {
                    var touch = Input.GetTouch(0);
                    if (touch.phase == TouchPhase.Began || touch.phase == TouchPhase.Moved)
                    {
                        var screenPosition = Camera.main.ScreenToViewportPoint(touch.position);
                        ARPoint point = new ARPoint
                        {
                            x = screenPosition.x,
                            y = screenPosition.y
                        };

                        // prioritize reults types
                        ARHitTestResultType[] resultTypes =
                        {
				    		//ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingGeometry,
	                        ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent, 
	                        // if you want to use infinite planes use this:
	                        //ARHitTestResultType.ARHitTestResultTypeExistingPlane,
	                        //ARHitTestResultType.ARHitTestResultTypeEstimatedHorizontalPlane, 
				    		//ARHitTestResultType.ARHitTestResultTypeEstimatedVerticalPlane, 
				    		//ARHitTestResultType.ARHitTestResultTypeFeaturePoint
	                    };

                        foreach (ARHitTestResultType resultType in resultTypes)
                        {
                            if (HitTestWithResultType(point, resultType))
                            {
                                return;
                            }
                        }
                    }
			   	}
               
                //  判断双指移动进行旋转
                if(Input.touchCount == 2 && Self_Transform!=null)
                {
                    Touch touch1 = Input.GetTouch(0);
                    Touch touch2 = Input.GetTouch(1);

                    
                    if(touch1.phase==TouchPhase.Began && touch2.phase == TouchPhase.Began)
                    {
                        BeginTouch1 = touch1;
                        BeginTouch2 = touch2;
                        return;
                    }
                    if(touch1.phase == TouchPhase.Moved &&touch2.phase == TouchPhase.Moved)
                    {
                        float x1 = BeginTouch1.position.x - touch1.position.x;
                        float x2 = BeginTouch2.position.x - touch2.position.x;
                        transform.eulerAngles += new Vector3(0, x2 / 2, 0);
                        //transform.Rotate(new Vector3(0, x1/2, 0));
                        BeginTouch1 = touch1;
                        BeginTouch2 = touch2;
                    }
                }

    		}
			#endif
		}
	}
}

